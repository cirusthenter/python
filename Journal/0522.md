# May 22, 2020
## クイックソート続き
- やっぱりフルスクラッチで書くのは大変むずかしいな

```python
def quick_sort(left: int, right: int, a: List[int]) -> None:
    pivot = a[(left + right) // 2]
    pl = left
    pr = right
    while pl < pr:
        while a[pl] < pivot:
            pl += 1
        while pivot < a[pr]:
            pr -= 1
        if pl < pr:
            a[pl], a[pr] = a[pr], a[pl]
            pl += 1
            pr -= 1
        else:
            break
    if left < pl - 1:
        quick_sort(left, pl - 1, a)
    if pr + 1 < right:
        quick_sort(pr + 1, right, a)
```

- こんなものを書いたら、正しくソートされなかった

## 今日知ったこと
- 正解の方では、

```python
    if left < pl:
        quick_sort(left, pl, a)
    if pr < right:
        quick_sort(pr, right, a)
```

ではなく、

```python
    if left < pl:
        quick_sort(left, pr, a)
    if pr < right:
        quick_sort(pl, right, a)
```

のように、分割後の関数呼び出しのときに pl と pr がクロスするような形で呼ぶんだと

- なるほど、クイックソートを知って1年半、ずっと間違っていたわ
    - たしかにこれでエッジケース考える必要がなくなるよな
- で、おまけに

```python
    while pl <= pr:
        while a[pl] < pivot:
            pl += 1
        while pivot < a[pr]:
            pr -= 1
        if pl <= pr:
            a[pl], a[pr] = a[pr], a[pl]
            pl += 1
            pr -= 1
    if left < pr:
        quick_sort(left, pl, a)
    if pl < right:
        quick_sort(pr, right, a)
```

- のように while の条件のところに等号もいれることによって、pl と pr が必ず通り過ぎるように (同じ位置に止まって終了しないようにしている)
    - これは賢い。いろいろなケースを考える必要がなくなっている
- そして、これによって、要素が一個しかない分割のソートをするようなこともなくなっている
- 覚えるべきことは、
    - 条件節のところに等号も含めることで、必ず左からのポインタと右からのポインタを交差させる (衝突ではなく交差！)
    - q(左端, 右からのポインタ); q(左からのポインタ, 右端);

```python
import time
from typing import List
import random

def quick_sort(a: List[int], left: int, right: int) -> None:
    pivot = a[(left + right) // 2]
    pl = left
    pr = right
    while pl <= pr:
        while a[pl] < pivot:
            pl += 1
        while pivot < a[pr]:
            pr -= 1
        if pl <= pr:
            a[pl], a[pr] = a[pr], a[pl]
            pl += 1
            pr -= 1
    if left < pr:
        quick_sort(a, left, pr)
    if pl < right:
        quick_sort(a, pl, right)

num = int(input("input an integer: "))
x = [random.randint(0, num) for _ in range(num)]
x2 = x.copy()

start1 = time.time()
quick_sort(x, 0, num - 1)
end1 = time.time()

start2 = time.time()
x2.sort()
end2 = time.time()

print("result:", "success" if x == x2 else "failed")
print("mine:", end1 - start1)
print("STL:", end2 - start2)
```

- 書けた、一発で
- 定期的にメンテが必要かもな

```
input an integer: 100000
result: success
mine: 0.28807687759399414
STL: 0.017068147659301758
```

- なんでライブラリはこんなに速いんだ？笑

```cpp
#include <cstdlib>
#include <iostream>
#include <vector>

void quick_sort(std::vector<int>& rand, int left, int right)
{
    int pivot = rand[(left + right) / 2];
    int pl = left;
    int pr = right;
    while (pl <= pr) {
        while (rand[pl] < pivot)
            ++pl;
        while (pivot < rand[pr])
            --pr;
        if (pl <= pr) {
            std::swap(rand[pl], rand[pr]);
            ++pl;
            --pr;
        }
    }
    if (left < pr)
        quick_sort(rand, left, pr);
    if (pl < right)
        quick_sort(rand, pl, right);
}

int main()
{
    std::vector<int> rand;
    std::cout << "input an integer: ";
    int num;
    std::cin >> num;

    for (int i = 0; i < num; ++i) {
        int x = std::rand();
        rand.push_back(x);
    }

    quick_sort(rand, 0, rand.size() - 1);
    int prev = rand[0];
    for (int n : rand) {
        if (n < prev) {
            std::cout << "failed" << std::endl;
            return 0;
        }
        prev = n;
    }
    std::cout << "success" << std::endl;

    return 0;
}
```

C++ でも書いてみた
